<!DOCTYPE html>
    <html lang="en">
        <head>
            <title>minecart3</title>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
            <meta name="generator" content="FreeCAD 0.19.24267 +148 (Git)" />
            <style>
                * { margin:0; padding:0; }
                body{
                    background: #ffffff; /* Old browsers */
                    background: -moz-linear-gradient(top, #e3e9fc 0%, #ffffff 70%, #e2dab3 100%); /* FF3.6-15 */
                    background: -webkit-linear-gradient(top, #e3e9fc 0%,#ffffff 70%,#e2dab3 100%); /* Chrome10-25, Safari5.1-6 */
                    background: linear-gradient(to bottom, #e3e9fc 0%,#ffffff 70%,#e2dab3 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
                }
                canvas { display: block; }
                #arrowCanvas  {
                  position: absolute;
                  left: 0px;
                  bottom: 0px;
                  z-index: 100;
                }
                select { width: 170px; }
            </style>
        </head>
        <body>
            <script type="module">
                
                // Direct from mrdoob - r122(10/28/20): https://www.jsdelivr.com/package/npm/three
                import * as THREE from            'https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.module.js';
                import { OrbitControls } from     'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/controls/OrbitControls.js';
                import Stats from                 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/libs/stats.module.js';
                import { GUI } from               'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/libs/dat.gui.module.js';
                import { Line2 } from             'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/Line2.js';
                import { LineMaterial } from      'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/LineMaterial.js';
                import { LineGeometry } from      'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/LineGeometry.js';
                import { EdgeSplitModifier } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/modifiers/EdgeSplitModifier.js';
                
                var disableCompression = false;
                var base = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!#$%&()*+-:;/=>?@[]^_,.{|}~`';
                var baseFloat = ',.-0123456789';
                
                THREE.Object3D.DefaultUp = new THREE.Vector3(0,0,1); // Z is up for FreeCAD
                
                var raycasterObj = []; // list of obj that can mouseover highlight 
                
                var scene = new THREE.Scene();
                
                var renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } ); // Clear bg so we can set it with css
                renderer.setClearColor( 0x000000, 0 );
                var mainCanvas = document.body.appendChild( renderer.domElement );
                mainCanvas.setAttribute('id', 'mainCanvas');
                
                // HemisphereLight gives different colors of light from the top and bottom simulating reflected light from the 'ground' and 'sky'
                scene.add(new THREE.HemisphereLight(0xC7E8FF, 0xFFE3B3, 0.4));
                
                var dLight1 = new THREE.DirectionalLight( 0xffffff, 0.4 );
                dLight1.position.set( 5, -2, 3 );
                scene.add( dLight1 );
                var dLight2 = new THREE.DirectionalLight( 0xffffff, 0.4 );
                dLight2.position.set( -5, 2, 3 );
                scene.add( dLight2 );
                
                var data = {"camera":{"type":"Orthographic","focalDistance":1777.3968505859375,"position_x":1203.7379150390625,"position_y":2205.6005859375,"position_z":806.032958984375},"file":{},"objects":[{"name":"Body","color":"#cccccc","opacity":1.0,"verts":"2 f b e c k k d k e a b b i b e j k e h b e g b e b c b b l b l l b l b b b m b o l b o b b n c k n l b n m b n b c o b s n q c p q r p k r i b r h b u h b t i b t g b u f b r f b t g b t v k r v q r l b s b q c b b c l b x l b w l l x b l w b l x b l s b d e b m e l o b b o b b a k c n b l n b a n k n a b o o b n o b o n b n l s n d e n m e n l x n l w o l x o b w o b x n b r n b e n q r n b b o b r n b y i l r o l r h z u h A r h A t h z e h A e i A t i A r i A e i l e g z u f l r f A r f A t f l e f A e g A t g A r g z e g A e l l r l b r b k r b q r b b b b b e b b y d b x j b x b d x b o x l o x b j x q b c q v r b v r b j e b p r b o s b o w l n w l n x l n s o n s i n e j n e f n e d n e g n e h n e o n w o o x o n x n o w n o x n o s n j e n v rrb v rrb b c n p r n d x n j xrb b r o n r n n r o o r o8b r o A r n q y p q9b p b9b o l e o A e l A e l l e l A r b n r l o r l n r l8b r q b r v b9b v q9b b q y l l9b o l9b b v9b q v9b q b y l o9b b p9b q p r q n c b n c b n y d n x j n x p n r prb r nrb c n n c brb c vrb r v n r f n r g n u g n t f n t h n u i n r i n t h n t n n yrb n crb p r n p9b n v9b o o9brb v9brb b yrb n r nrb r i o r o8b e o o e f8b r g8b r h8b r i8b r n b9b n q9b o b9b l o e l8b e f o r brb r q n r l b9b b b9b b q9b b l9b q b9b b o9b q p9b q n y b n b b n e v n9b vrb9b brb y p n9b n n b n n e gCc u g8b t gCc e g8b e f8b t f8b e f o e hCc u i8b t i o e i8b e h8b t hCc e h8b e nrb y prb9brb n yrb p9b n l9b n o9brb b9b o n9b l n9b b n9b q n9b brb9b n n9b nrb9brb n9b","facets":"2 a b c d e f d b e e b g g b h h b a i j k b k l b i k m i b d m b n d o p n q p d n r m d r d p s t u t d u f v d d v u f w v w e x f e w y z A x y A g y x e g x g h B g B y B C D B D E h a C h C B a c F a F C F c G c b G H I b b I G H J I K L M l k H k M H H M L M N O k j P M k N N k P Q m R i m Q P j i S T U V W S V U m V S U X m r X r Y X V m Z X Y 1 Z Y 2 X Z q 3 p r 4 5 r p 4 6 7 8 q n 3 n 8 3 3 8 7 8 9 0 n o t 8 n 9 9 n t H b l t o d ! # $ # % $ % u $ % s u w & v & $ v & ! $ 9 t ( ( t s $ u v ) w x w * & ) * w + - : + : z y + z ; / - ; - + ) x A = ) A > ) = ? @ ) ? ) > z = A : = z B + y [ + B ] ^ _ ] _ D , . ^ , ^ ] C ] D [ B E { [ E | } [ | [ { ~ } | D { E _ { D ` Fab F ] C ` ] Fbbabcbab Gcbab F G Jdb Iebcbdbdbcb Iebbbcbfb J L J H L G Icb Mgb Khb 8 0 M 8gbgb 8hbgb L K N Pfbfb P J O Nib Oib Mjbkblbkb Mlblb Mib J Pmb P imb Qnb i inbmb Qobnb Rpbqbob Rqb Q Rob mpb R m Upbrb U Tjbsbkb T Srb Skbrbrbkbsbkbtbub S Wvbkb Stbtb Svb 2wb Xxb Xyb VzbAb V Xzbzb XBbBb XCbCb Xxb W VvbDbEbFb 2 Zwb ZEbDb ZDbwbGbHbEb Z 1IbEb ZIbEbIbGbJb r 5 Y rJb YIb 1Kb 4Lb 4 pLb 3Mb p pMbLb 3 sMb 5 4KbNb 5KbJb 5NbOb 6 8EbHbPb 8EbPb 8PbOb ( s 7 s 3 7 7 6Ob 0 9hb s %Mb #Qb % %QbMb # !Qb * ! & *Kb !RbSbTbTbSbNbNbKbUbUbKbVbUbTbNb *VbKb 9 (WbXbhb 9Xb 9WbYbhbXb )Zb * @Zb ) ~ / } } / ; } ; + } + [ > = : - > : / ~ | / | - ?1b @ @1bZb1b ? >1b >Vb2b .3b3b . ,3b , ]3b ] ` | { _ ^ | _ .2b4b .4b ^bb `abbbob `5b6bqb5b7b6b4b `ob6b8bqbobqb4b4bqb8bbbeb9bebdb9bdbmb9bdb Jmbgb0b!b Lgb!b#b L!bfb L#bYb0bgbYbgbhb$b%b 8$b 8 M&bib(bib N(b N)b(b Nfb)b*b$b M*b Mkblbsbjbib+blb&b+bibobbbnbnbbb9b9bmbnbqbpb-bpb U-brb:b U U:b-brb;b:b/b;bsb;brbsbtbvb/b/bvb;btb=bub>bFbEb=b>bEbkb=bEbub=bkb?byb@byb X@bwb[b X X[b@bwb]b[b;bvb^bvb V^bAb_b V V_b^bAb,b_b,bzb.bAbzb,b{b|b}b.b{b}bBb{b.bzbBb.bBbCb~bBb~b{b~b`bac~bacbcCbxb`bCb`b~bxbyb?bxb?b`bwbDbccwbcc]bDbFb>bIb]bccIbccGbPbHbGb]bIbdcIb YdcJbec Y YecdcJbNbec !KbQbQbKbLbMbQbLbfcObPbfcgcOb%bhc 8 8hcEbObgcic 7Obicjc 7ic ( 7jcNbSbececSbkcSbRblcRb@blcRb?b@b`b?bmc?bTbmc?bRbTbncocTbncTbUb4bpc ^8bpc4b ^qc |pcqc ^ |rc -qcrc | -sc >rcsc - >UbVbscUb >Zb1bVbZbVb * (tcuc (ucWbvcYbXbucvcXbtcvcucWbucXb2b3b `2b `4bwcxc8bwc8b6b7b,b6b,byc6b,b.byc,b7b_b7bzc_b7b5bzc5bqbAcAcqb-bBcCcDc!bBcDc0bBc!bCcfb#bCc#bDc#b!bDc0b$bBc%bYbvc%b$b0b%b0bYbCcEcFcEc(bFcEc&b(bfbCc)b)bCcFc)bFc(bhc*bEbEb*bkb&bEc$b*bGc+b$b*b+b$b+b&blb+bHcIcsblbIclbHc/bsbIc;bJc:bKcAcJcJcAc:bKc5bAc-b:bAcLc=bMctbNc=b=bNcMctb/bNcLcOc=b=bOc>b]bPc[bQclcPcPclc[bQcSblc[blc@b5bKczcKcJczcJc^bzcJc;b^b_bzc^bRcqcScRcSc|b{bRc|bTcUcqcTcqcRcyc.b}bVcyc}bpcycVcWcXcycWcycpcVc|bSc}b|bVcRc~bYc{b~bRcmcscZcmcZcac1c2csc1cscmc`bmcacYc~bbc3cYcbcrc4cYcrcYc3c5c4crc3cacZcbcac3cccDb6cDb>b6c>b7c6c>bOc7cGbcc8cPbGb8c9cPb8cfcPb9cSbQckcQcPckcPcdckcPc]bdcdceckc0cgc%b!chcfchc%bfcfc%bgc0ctc#cic0c#cgc0cictc (jctcjc#c#cjcicTb1cmcoc1cTb2cocnc1coc2cscncUb2cncscrc3cZcscrcZcUc5crcUcrcqcpcVcScqcpcScxcWcpcxcpc8btc%bvc0c%btcxcXcWcwcXcxcXcwc6bXc6byc$bCcBc$bEcCc$cOchcLc*bOcOc*bhcLc%c*b&cGc*b%c&c*bGc&c(cHcGc(c+bGcHc&c/bIc&cIc(cIcHc(c&c%c)c%cMc)c%cLcMc/b&cNcNc&c)cMcNc)cUc4c5cTc4cUc4cTcRc4cRcYc*ccc+c+ccc6cOc$c7c$c+c7c$c*c+c+c6c7ccc*c-ccc-c8c!cfc9c-c!c9c*c!c-c-c9c8c*c$c!c!c$chc","wires":["1abbcbbdbefbegbehbeibejkeakk","1abbcbblbbllbblbbcbbmbnmbncbnlbolbobbabb","1pqrpkrjkeakkobsnbcnqcpqr","1jbeibeibrpkrjke","1ibtibribehbehbuhbtibt","1hbuhbegbegbuhbu","1gbtgbugbefbefbrfbtgbt","1fbedkevbrfbrfbe","1bqckbclbscbbdkevkrvqrbqc","1lbwlbslbbllbllxlbxlbw","1llbblbblsblwblxllxllb","1bcbbmbbmebdebck","1blsblbbckbls","1nabnmbbmbbabbobloblnbcnbanbonboobnobnab","1nlbnlsncbnlb","1ncbndenmenmbncb","1nlwnlsnlbolbolxnlxnlw","1olbobbobsobwobxolxolb","1lbblbscbblbb","1obsobbakkobs","1nqcnbcnbbnbenkrnqrnqc","1nqrnbrobrpkrpqrnqr","1obwnbynbcobsobw","1pqrnqrnqcpqr","1pbribrilrolrobrpbr","1hzehAehArhAthbthbuhzuhze","1ibtiAtiAriAeileilribribt","1ibthbthAtiAtibt","1hbugbugzuhzuhbu","1flefAefArfAtfbtfbrflrfle","1gbtgAtgArgAegzegzugbugbt","1gbtfbtfAtgAtgbt","1vbrlbrlBrlCrlDrlErlFrlGrlHrlIrlJrlKrlLrllrflrfbrvbr","1vqrvbrlbrbkrbqrvqr","1bqrbbrbbebbbbbcbqcbqr","1kbylbwlbMlbNlbOlbPlbQlbRlbSlbTlbUlbVlbWlbXlbYlbZlb1lbsbbcbby","1bqcbqrvqrbqc","1dbxlbxlBxlCxlDxlExlFxlGxlHxlIxlJxlKxlLxllxolxobxjbxdbx","1lbxdbx2b34b56b78b90b!#b$%b&(b)*b+-b:;b/=b>?b@[b]^b_lbwlbx","1bkyblwblMblNblOblPblQblRblSblTblUblVblWblXblYblZbl1blsbbcbby","1blxbdxb23b45b67b89b0!b#$b%&b()b*+b-:b;/b=>b?@b[]b^_blwblx","1llxblxbdxbjxboxloxllx","1qvrbvrbdebckblsbbcqbcqvr","2 b m e b j e b , . b { | b } ~ b `ab bbbcb bdbeb bfbgb bhbib bjbkb blbmb bnbob bpbqb b p r b v r b d e b m e","1babbjebmebmbbab","1bobbosbabbob","1bowbosboblobloxboxbow","1loblnblnslnwlnxloxlob","1onbonsanbonb","1cnbanbjneinehnegnefnednecnk","1cnklnslnbcnb","1onboobooxonxonwonsonb","1nownosnoboobooxnoxnow","1nabnmbnmenjenak","1nosnobnaknos","2rb b c n k c n l s n c b n d e n v rrb v rrb b c","2 n m e n d e nsb . ntb | nub ~ nvbab nwbcb nxbeb nybgb nzbib nAbkb nBbmb nCbob nDbqb n v r n p r n j e n m e","1ooxnoxnjxndxnlxolxoox","1nkynlwnlMnlNnlOnlPnlQnlRnlSnlTnlUnlVnlWnlXnlYnlZnl1nlsnbcnby","1nlxndxn23n45n67n89n0!n#$n%&n()n*+n-:n;/n=>n?@n[]n^_nlwnlx","2 o b x o b wEb bFbGb bHbIb bJbKb bLbMb bNbOb bPbQb bRbSb bTbUb bVbWb bXbYb bZb1b b2b3b b4b5b b6b7b b _ j b x o b x","2rb b r n b r n b e n b b n b crb b crb b r","2 n b r o b r o l r o A r o8b r o o r o n r n n r n p r n v r n b r","2 p q9b p b9b j b x o b w n b y n q y p q9b","1ilrileoleolrilr","1gzegAehAehzegze","1gzugzehzehzugzu","1iAthAthAriAriAt","1hAegAegArhArhAe","1ileiAeoAeoleile","1oAeiAeiAroAroAe","1llelAefAeflelle","1llrllefleflrllr","1gAtfAtfArgArgAt","1fAelAelArfArfAe","2 l b r b b r b v r b p r b n r l n r l o r l8b r l A r l l r l b r","1qbcbbcbbbbbebbrqbrqbc","2 b q y k b y l b w d b x v b9b v q9b b q y","2 j b x p b9b0b b9b!b b9b#b b9b$b b9b%b b9b&b b9b(b b9b)b b9b*b b9b+b b9b-b b9b:b b9b;b b9b/b b9b m b9b v b9b d b x j b x","2 o l9b o l x l l x l l9b o l9b","2 q b y b k y b l w b d x b v9b q v9b q b y","2 l l9b l l x l o x l o9b l l9b","2 b o x b j x b=b 3 b>b 5 b?b 7 b@b 9 b[b ! b]b $ b^b & b_b ) b,b + b.b : b{b / b|b > b}b @ b~b ] b7b _ b o w b o x","2 b d x b v9b b p9b b j x b d x","1qbrbbrbvrqvrqbr","1qvrqbrqbcqvr","1qncbncbosbabbjebprqprqnc","1bnybowboMboNboOboPboQboRboSboTboUboVboWboXboYboZbo1bosbncbny","1knylnwlnMlnNlnOlnPlnQlnRlnSlnTlnUlnVlnWlnXlnYlnZln1lnsbncbny","1dnxlnxln5ln7ln9ln!ln$ln&ln)ln+ln:ln/ln>ln@ln]ln_lnwdnx","1lnxdnxjnxonxooxloxlnx","2 nrb c n n c o n s a n b j n e p n r prb r nrb c","2 vrb r v n r d n e c n k l n s b n c brb c vrb r","1dnefnefnrvnrdne","1fntfnrfnegnegnugntfnt","1gnugnehnehnugnu","1hnthnuhneineinrinthnt","1inejnepnrinrine","2 n n c o n s o n`b o nac o nbc o ncc o ndc o nec o nfc o ngc o nhc o nic o njc o nkc o nlc o nmc o n 1 o n w n n y n n c","2 o n x o n wEb nFbGb nHbIb nJbKb nLbMb nNbOb nPbQb nRbSb nTbUb nVbWb nXbYb nZb1b n2b3b n4b5b n6b7b n _ j n x o n x","1nosnncnnynownos","1njxnoxno5no7no9no!no$no&no)no+no:no/no>no@no]no_nownjx","2rb p r n p r n j e n a k n o s n n crb n crb p r","2rb v r n v r n b rrb b rrb v r","2rb b crb b rrb v rrb b c","2 n j x n p9b n0b9b n!b9b n#b9b n$b9b n%b9b n&b9b n(b9b n)b9b n*b9b n+b9b n-b9b n:b9b n;b9b n/b9b n m9b n v9b n d x n j x","2 o l x o l9b o o9b o o x o l x","2rb b y n k y n l w n d x n v9brb v9brb b y","2rb n r n n r n p rrb p rrb n r","2 prb r p n r o n r n n r nrb r prb r","1ooriorinrpnronroor","2 o8b e o o e o o r o8b r o8b e","2 f A r l A r l8b r f8b r g8b r h8b r i8b r o8b r o A r i A r h A r g A r f A r","1oleoAeoArolrole","2 n q y n b y n b9b n q9b n q y","2 n q9b n b9b o b9b p b9b p q9b n q9b","2 n q9b p q9b n q y n q9b","1lAellellrlArlAe","2 l o e l8b e l8b r l o r l o e","1forlorlnrvnrfnrfor","2 brb r b n r l n r v n r vrb r brb r","1qprbprbnrqnrqpr","2 v q9b v b9b l b9b b b9b b q9b v q9b","2 b q9b b b9b b b y b q y b q9b","2 b q9b k q y v q9b b q9b","2 l b9b v b9b p b9b o b9b o l9b l l9b l b9b","2 q v9b b v9b b l9b b b9b q b9b q v9b","2 q b9b b b9b b b y q b y q b9b","2 q b y q b9b q v9b q b y","2 o o x o o9b l o9b l o x o o x","2 b v9b b p9b b o9b l o9b l l9b b l9b b v9b","2 q n y b n y b o w b j x b p9b q p9b q n y","1qnrbnrbnebnbbncqncqnr","1qncqnrqprqnc","2 brb y k n y l n w d n x v n9b vrb9b brb y","2 p n9b j n xnc n xoc n xpc n xqc n xrc n xsc n xtc n xuc n xvc n xwc n xxc n xyc n xzc n xAc n xBc n x m n x d n x v n9b p n9b","2 nrb r n n r n n e n n b n n c nrb c nrb r","2 nrb r prb r nrb c nrb r","2 brb c b n c b n b b n e b n r brb r brb c","2 brb r brb c vrb r brb r","2 gCc e g8b e g8b r g8b t g n t g n u gCc u gCc e","2 f n t f8b t f8b r f8b e f o e f o r f n r f n t","2 g8b t f8b t f n t g n t g8b t","2 hCc u gCc u g n u h n u hCc u","2 i o e i8b e i8b r i8b t i n t i n r i o r i o e","2 h n t h8b t h8b r h8b e hCc e hCc u h n u h n t","2 i8b t h8b t h n t i n t i8b t","2 prb9b p n9b j n x o n w n n y nrb y prb9b","2rb p9b n p9b n j x n o w n n yrb n yrb p9b","2rb n c n n c n n b n n e n n rrb n rrb n c","2rb p rrb n rrb n crb p r","2 o l9b n l9b n v9b n p9b n o9b o o9b o l9b","2rb v9b n v9b n l9b n b9brb b9brb v9b","2rb b9b n b9b n b yrb b yrb b9b","2rb b9brb k yrb v9brb b9b","1oorooeioeioroor","2 o8b e i8b e i o e o o e o8b e","2 i8b e o8b e o8b r i8b r i8b e","2 h8b t i8b t i8b r h8b r h8b t","2 g8b e h8b e h8b r g8b r g8b e","2 f8b t g8b t g8b r f8b r f8b t","2 l8b e f8b e f8b r l8b r l8b e","2 o b9b n b9b n l9b o l9b o b9b","2 f8b e l8b e l o e f o e f8b e","1forfoeloelorfor","2 b b9b l b9b l l9b b l9b b b9b","2 v n9b l n9b lDc9b lEc9b lFc9b lGc9b lHc9b lIc9b lJc9b lKc9b lLc9b lMc9b lNc9b l o9b o o9b o n9b p n9b v n9b","2 b o9b l o9b l n9b b n9b b o9b","2 q p9b b p9b b o9b b n9b q n9b q p9b","2 q n9b b n9b b n y q n y q n9b","2 q n9b q n y q p9b q n9b","2 vrb9b v n9b l n9b b n9b brb9b vrb9b","2 brb9b b n9b b n y brb y brb9b","2 brb y brb9b vrb9b brb y","2 h8b e g8b e gCc e hCc e h8b e","2 hCc u hCc e gCc e gCc u hCc u","2 nrb y n n y n n9b nrb9b nrb y","2 nrb9b n n9b o n9b p n9b prb9b nrb9b","2 prb9b nrb9b nrb y prb9b","2rb n y n n y n n9brb n9brb n y","2rb n9b n n9b n o9b n p9brb p9brb n9b","2rb n9brb p9brb n yrb n9b","2 n n9b o n9b o o9b n o9b n n9b"],"faceColors":[],"facesToFacets":["1abcdef","1ghijklmnop","1qrstu","1vw","1xyzA","1BC","1DEFG","1HI","1JKLMN","1OPQR","1STUV","1WX","1Y","1Z123456789","10","1!#","1$%&(","1)*+-","1:","1;","1/=>?","1@[]","1^_","1,","1.{|","2 } ~ `abbb","2cbdbebfbgb","2hbib","2jbkb","2lbmbnbobpb","2qbrbsbtbub","2vbwb","2xbybzb","2AbBbCb","2DbEbFbGb","2HbIb","2Jb","2KbLbMbNb","2Ob","2PbQb","2Rb","2SbTbUbVb","2WbXbYbZb1b","22b3b4b","25b6b","27b","28b9b0b!b","2#b$b%b&b","2(b","2)b*b+b-b:b;b","2/b","2=b>b?b@b","2[b]b^b_b","2,b.b","2{b","2|b}b~b`bac","2bcccdc","2ecfcgchc","2icjc","2kc","2lc","2mcncocpc","2qcrcsctcucvcwcxc","2yczcAcBc","2CcDc","2EcFc","2GcHc","2IcJc","2KcLc","2McNc","2OcPc","2QcRc","2ScTc","2UcVc","2WcXc","2YcZc1c2c3c4c5c6c","27c8c9c0c","2!c#c$c%c","2&c(c","2)c*c","2+c-c:c;c","2/c=c","2>c","2?c@c","2[c]c","2^c","2_c,c.c{c|c","2}c~c","2`cad","2bd","2cdddedfd","2gdhdidjdkd","2ldmdndodpd","2qdrd","2sdtdudvd","2wdxd","2ydzdAdBd","2CdDd","2EdFd","2Gd","2HdId","2Jd","2KdLdMdNdOd","2PdQd","2Rd","2SdTd","2UdVd","2WdXdYdZd","21d2d","23d4d5d","26d7d8d","29d0d","2!d#d$d%d&d(d)d*d+d-d","2:d;d","2/d=d","2>d?d@d","2[d","2]d^d","2_d,d","2.d{d|d","2}d~d`d","2aebe","2cedeee","2fege","2he","2iejekele","2meneoe","2peqe","2re","2sete","2uevewexe","2yezeAeBe","2CeDeEeFe","2Ge","2HeIeJeKe","2LeMe","2NeOePeQe","2Re","2SeTeUeVe","2We","2XeYeZe1e2e","23e4e5e6e7e","28e9e","20e!e","2#e$e%e&e(e","2)e*e+e-e:e","2;e/e","2=e>e?e@e","2[e]e^e_e","2,e.e{e|e","2}e","2~e`eafbf","2cfdfef","2ffgf","2hf","2ifjf","2kflf","2mfnf","2ofpf","2qfrf","2sftf","2ufvf","2wfxf","2yfzf","2AfBf","2CfDf","2EfFfGfHf","2IfJf","2KfLfMf","2NfOf","2Pf","2QfRfSf","2TfUf","2Vf","2WfXf","2YfZf","21f2f","23f4f5f","26f","27f8f","29f0f!f","2#f","2$f%f"],"floats":"S{wE_?TvI5UvRaTulG&dS>Tv~@yi[Xv06:Lvb0UvE:zG?LKv~@yiigsEB>Tvd0UvpuQ;!azgx^TvRaTuO#Pc~4Uvu{+(X0|te?Tv~@yi:,TS[>Jv~@yi|CcsLALvi0UvghNW(xdui0Uvqn}w~mmuneUvHg/k!OTu*`ZbOW3AtX8J_W9>2nT.9CF8R,kjsJ[HAz6d9PEuMYKva6Uv+b[u5)[ftgCz]^bnM]U>eJRy-Qo-28.V(oqO3?O#[Hm]ll@fE2}-Dh[k*r&=TAtL!k9y:a,/>Kyu%m53LWCBjj&dYdI?Y!GVij&d(%6)9JGVgj&dI7$XR-FVbj&dd[[?LVEV[i&de.!*owBV4i&d~e=Zu0uVgi&d#+),mShVf/%dFpE^dFZO&%$dvag=}@)H5_#dC4O!Jmn]KA!dq]ALd4ROL=UdIK43}#GB{|MdA]Tv_5Y;=nwdw]TvLWCB(b*cj]TvpuQ;4fDc:|I^qa(H4fDcymp=kx(H4fDcFG3!N*(H4fDcqQ3L3-)H3fDcJuF4W2-H2fDcysix:N>HYfDczf9yc||H%dDcY/FD4YMO/bDcR4BL5rlVc~Cc%l53tPU9:`Bc04UvLWCBt(Bc!4Uv!^kBh7RcJ5Uvqa(HmG&d0`t?_HLi071WZ!9JhCTE2{hDa:k;rB,_4YMOP^&d~P43eIdmnffX:wLvb0UvK]}-0Lk8Gnhww]}-[l4F166w,[}-Fx=RTJ*xw[}-]C&%*1nAT?}-+*GT|aCGa/}-nXE-!76S~&}-;If5$&K*=y.-EJRy.=hZ6g+-+.fDVEr_pU8-?GtL_/8>vJM-K]V3Z=3%>~$+UKMv$[mT%71*#OMv[qL+>Z5%A4Mvgr53!/J8e8Mvgr53P$LLLOKvAZmnN9,D).6T18M]QsBc1nY+=e*%;?a;]1rC8l(SXceD=^DkI*^DI]AL;C>2ZSAcdm53}YiDxFdub0Uv&JpELPKvJ)CikgsE.~.MlMR;JhDc;M&^G+UzX2zH!76S-jCW4.OZN1XkQNtEP$UGth!O(HDc(Ew@|m/P.[du[qL+Kz83peLvkAswe+q!;b4UN>@7y(+H!nMdzi:T`NZkrlUS)(f6CRi@iu&#f0$[v{8>K|29DQWd[PK+y56mSmk1KPKv#[qne;rEMeo.Sft(3fDcSAj:CUcz/JVUrIy4vNyW.UBR_%Ri2~qE(&._9T1uV@Bc0/mTwB@+-2du[qL+zE{MUKKv~@yiK]bGw^TvzfQ]oRRc$G3!UZ9GRkc;)ii?fhF=wleD=^DkU|yGf^ALvli(ZJRcim53b]gC)?eu}9Uv"}]};
                
                function baseDecode( input ) {
                    var baseCt = base.length;
                    var output = [];
                    var len = parseInt( input[0] ); // num chars of each element
                    for ( var i=1; i<input.length; i+=len ) {
                        var str = input.substring(i, i+len).trim();
                        var val = 0;
                        for ( var s=0; s<str.length; s++ ) {
                            var ind = base.indexOf(str[s]);
                            val += ind * Math.pow(baseCt, s);
                        }
                        output.push(val);
                    }
                    return output;
                }
                function floatDecode( input ) {
                    var baseCt = base.length;
                    var baseFloatCt = baseFloat.length;
                    var numString = '';
                    for ( var i=0; i<input.length; i+=4 ) {
                        var b90chunk = input.substring(i, i+4).trim();
                        var quotient = 0;
                        for ( var s=0; s<b90chunk.length; s++ ) {
                            var ind = base.indexOf(b90chunk[s]);
                            quotient += ind * Math.pow(baseCt, s);
                        }
                        var buffer = '';
                        for ( var s=0; s<7; s++ ) {
                            buffer = baseFloat[ quotient % baseFloatCt ] + buffer;
                            quotient = parseInt(quotient / baseFloatCt);
                        }
                        numString += buffer;
                    }
                    var trailingCommas = 0;
                    for ( var s=1; s<7; s++ ) {
                        if( numString[ numString.length-s ] == baseFloat[0] ) { trailingCommas++; }
                    }
                    numString = numString.substring(0, numString.length - trailingCommas);
                    return numString;
                }
                // Decode from base90 and distribute the floats
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    if (!disableCompression) {
                        data.objects[obj].floats = JSON.parse('[' + floatDecode( data.objects[obj].floats ) + ']');
                        data.objects[obj].verts = baseDecode( data.objects[obj].verts );
                        for ( var v=0; v<data.objects[obj].verts.length; v++ ) {
                            data.objects[obj].verts[v] = data.objects[obj].floats[ data.objects[obj].verts[v] ];
                        }
                        data.objects[obj].facets = baseDecode( data.objects[obj].facets );
                        for ( var w=0; w<data.objects[obj].wires.length; w++ ) {
                            data.objects[obj].wires[w] = baseDecode( data.objects[obj].wires[w] );
                            for ( var wv=0; wv<data.objects[obj].wires[w].length; wv++ ) {
                                data.objects[obj].wires[w][wv] = data.objects[obj].floats[ data.objects[obj].wires[w][wv] ];
                            }
                        }
                        for ( var f=0; f<data.objects[obj].facesToFacets.length; f++ ) {
                            data.objects[obj].facesToFacets[f] = baseDecode( data.objects[obj].facesToFacets[f] );
                        }
                    }
                    data.objects[obj].floats = false;
                }
                
                // Get bounds for global clipping
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    if (obj == 0) {
                        var globalMaxMin = [{min:data.objects[obj].verts[0],max:data.objects[obj].verts[0]},
                                            {min:data.objects[obj].verts[1],max:data.objects[obj].verts[1]},
                                            {min:data.objects[obj].verts[2],max:data.objects[obj].verts[2]}]
                    }
                    for ( var v=0; v<data.objects[obj].verts.length; v++ ) {
                        if ( data.objects[obj].verts[v] < globalMaxMin[v % 3].min ) { globalMaxMin[v % 3].min = data.objects[obj].verts[v]; }
                        if ( data.objects[obj].verts[v] > globalMaxMin[v % 3].max ) { globalMaxMin[v % 3].max = data.objects[obj].verts[v]; }
                    }
                }
                var bigrange = 0;
                for ( var i=0; i<globalMaxMin.length; i++ ) { // add a little extra
                    var range = globalMaxMin[i].max - globalMaxMin[i].min;
                    if ( range > bigrange ) { bigrange = range; }
                    globalMaxMin[i].min -= range * 0.01;
                    globalMaxMin[i].max += range * 0.01;
                }
                
                var camCenter = new THREE.Vector3(
                    0.5 * (globalMaxMin[0].max - globalMaxMin[0].min) + globalMaxMin[0].min,
                    0.5 * (globalMaxMin[1].max - globalMaxMin[1].min) + globalMaxMin[1].min,
                    0.5 * (globalMaxMin[2].max - globalMaxMin[2].min) + globalMaxMin[2].min );
                var viewSize = 1.5 * bigrange; // make the view area a little bigger than the object
                var aspectRatio = window.innerWidth / window.innerHeight;
                var originalAspect = aspectRatio 
                function initCam(camera) {
                    camera.position.set(
                        data.camera.position_x,
                        data.camera.position_y,
                        data.camera.position_z);
                    camera.lookAt( camCenter );
                    camera.updateMatrixWorld();
                }
                var cameraType = data.camera.type;
                var persCamera = new THREE.PerspectiveCamera( data.camera.focalDistance, window.innerWidth / window.innerHeight, 1, 10000 );
                initCam(persCamera);
                var orthCamera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, -10000, 10000);
                initCam(orthCamera);
                
                function assignMesh( positions, color, opacity ) {
                    
                    var geometry = new THREE.BufferGeometry();
                    geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                    
                    // EdgeSplitModifier is used to combine verts so that smoothing normals can be generated WITHOUT removing the hard edges of the design
                    // REF: https://threejs.org/examples/?q=edge#webgl_modifier_edgesplit - https://github.com/mrdoob/three.js/pull/20535
                    var edgeSplit = new EdgeSplitModifier();
                    var cutOffAngle = 20;
                    geometry = edgeSplit.modify( geometry, cutOffAngle * Math.PI / 180 );
                    geometry.computeVertexNormals();
                    geometry.computeBoundingSphere();
                    
                    var transparent = false;
                    if (opacity != 1.0) { transparent = true; }
                    var material = new THREE.MeshLambertMaterial({
                        color: color,
                        side: THREE.DoubleSide,
                        vertexColors: false,
                        flatShading: false,
                        opacity: opacity,
                        transparent: transparent,
                        fog: false
                    });
                    
                    var meshobj = new THREE.Mesh( geometry, material );
                    meshobj.name = meshobj.uuid;
                    faces.push( meshobj.uuid );
                    scene.add( meshobj );
                    raycasterObj.push(meshobj);
                }
                
                var objects = [];
                var positions;
                for ( var obj=0; obj<data.objects.length; obj++ ) { // Loop Objects
                    
                    var faces = []; // Each face gets its own material because they each can have different colors
                    if (data.objects[obj].facesToFacets.length > 0) {
                        for ( var f=0; f<data.objects[obj].facesToFacets.length; f++ ) {
                            var facecolor = data.objects[obj].color;
                            if (data.objects[obj].faceColors.length > 0) {
                                facecolor = data.objects[obj].faceColors[f];
                            }
                            positions = new Float32Array( data.objects[obj].facesToFacets[f].length * 9 );
                            for ( var a=0; a<data.objects[obj].facesToFacets[f].length; a++ ) {
                                for ( var b=0; b<3; b++ ) {
                                    for ( var c=0; c<3; c++ ) {
                                        positions[ 9*a + 3*b + c ] = data.objects[obj].verts[ 3*data.objects[obj].facets[ 3*data.objects[obj].facesToFacets[f][a] + b ] + c ];
                                    }
                                }
                            }
                            assignMesh( positions, facecolor, data.objects[obj].opacity );
                        }
                    } else { // No facesToFacets means that there was a tessellate() mismatch inside FreeCAD. Use all facets in object create this mesh
                        positions = new Float32Array( data.objects[obj].facets.length * 3 );
                        for ( var a=0; a<data.objects[obj].facets.length; a++ ) {
                            for ( var b=0; b<3; b++ ) {
                                positions[ 3*a + b ] = data.objects[obj].verts[ 3*data.objects[obj].facets[a] + b ];
                            }
                        }
                        assignMesh( positions, data.objects[obj].color, data.objects[obj].opacity );
                    }
                    
                    // Wires
                    // cannot have lines in WebGL that are wider than 1px due to browser limitations so Line2 workaround lib is used
                    // REF: https://threejs.org/examples/?q=fat#webgl_lines_fat - https://jsfiddle.net/brLk6aud/1/
                    var wirematerial = new LineMaterial( {
                        color: new THREE.Color('rgb(0,0,0)'),
                        linewidth: 2, // in pixels
                        dashed: false, dashSize: 1, gapSize: 1, dashScale: 3
                    } );
                    wirematerial.resolution.set( window.innerWidth, window.innerHeight );
                    
                    var wires = [];
                    for ( var w=0; w<data.objects[obj].wires.length; w++ ) {
                        var wiregeometry = new LineGeometry();
                        wiregeometry.setPositions( data.objects[obj].wires[w] );
                        var wire = new Line2( wiregeometry, wirematerial );
                        wire.computeLineDistances();
                        wire.scale.set( 1, 1, 1 );
                        wire.name = wire.uuid;
                        scene.add( wire );
                        wires.push( wire.name );
                    }
                    objects.push( { name: data.objects[obj].name, faces: faces, wires: wires } );
                }
                
                // ---- GUI Init ----
                const gui = new GUI( { width: 300 } );
                var guiparams = {
                    wiretype: 'Normal',
                    wirewidth: wirematerial.linewidth,
                    wirecolor: '#'+wirematerial.color.getHexString(),
                    clippingx: 100,
                    clippingy: 100,
                    clippingz: 100,
                    cameraType: cameraType,
                    navright: function() { navChange( [1,0,0] ); },
                    navtop:   function() { navChange( [0,1,0] ); },
                    navfront: function() { navChange( [0,0,1] ); }
                };
                
                // ---- Wires ----
                if (!wirematerial.visible) { guiparams.wiretype = 'None'; }
                if (wirematerial.dashed) { guiparams.wiretype = 'Dashed'; }
                const wiretypes = { Normal: 'Normal', Dashed: 'Dashed', None: 'None' };
                
                var wireFolder = gui.addFolder( 'Wire' );
                wireFolder.add( guiparams, 'wiretype', wiretypes ).name('Wire Display').onChange( wireChange );
                wireFolder.add( guiparams, 'wirewidth').min(1).max(5).step(1).name('Wire Width').onChange( wireChange );
                wireFolder.addColor( guiparams, 'wirecolor' ).name('Wire Color').onChange( wireChange );
                wireFolder.close();
                
                function wireChange() {
                    for ( var obj=0; obj<objects.length; obj++ ) {
                        if ( objects[obj].wires.length == 0 ) { continue; }
                        var m = scene.getObjectByName( objects[obj].wires[0] ).material; // all wires in obj share mat
                        if (m.dashed) {
                            if (guiparams.wiretype != 'Dashed') {
                                m.dashed = false;
                                delete m.defines.USE_DASH;
                            }
                        } else {
                            if (guiparams.wiretype == 'Dashed') {
                                m.dashed = true;
                                // Dashed lines require this as of r122. delete if not dashed
                                m.defines.USE_DASH = ""; // https://discourse.threejs.org/t/dashed-line2-material/10825
                            }
                        }
                        if (guiparams.wiretype == 'None') {
                            m.visible = false;
                        } else {
                            m.visible = true;
                        }
                        m.linewidth = guiparams.wirewidth;
                        m.color = new THREE.Color(guiparams.wirecolor);
                        m.needsUpdate = true;
                    }
                }
                wireChange();
                
                // ---- Clipping ----
                var clippingFolder = gui.addFolder( 'Clipping' );
                clippingFolder.add( guiparams, 'clippingx').min(0).max(100).step(1).name('X-Axis Clipping').onChange( clippingChange );
                clippingFolder.add( guiparams, 'clippingy').min(0).max(100).step(1).name('Y-Axis Clipping').onChange( clippingChange );
                clippingFolder.add( guiparams, 'clippingz').min(0).max(100).step(1).name('Z-Axis Clipping').onChange( clippingChange );
                clippingFolder.close();
                
                var clipPlaneX = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), 0 );
                var clipPlaneY = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), 0 );
                var clipPlaneZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), 0 );
                function clippingChange() {
                    if( guiparams.clippingx < 100 || guiparams.clippingy < 100 || guiparams.clippingz < 100 ) {
                        if (renderer.clippingPlanes.length == 0) {
                            renderer.clippingPlanes.push( clipPlaneX, clipPlaneY, clipPlaneZ );
                        }
                    }
                    clipPlaneX.constant = (globalMaxMin[0].max - globalMaxMin[0].min) * guiparams.clippingx / 100.0 + globalMaxMin[0].min;
                    clipPlaneY.constant = (globalMaxMin[1].max - globalMaxMin[1].min) * guiparams.clippingy / 100.0 + globalMaxMin[1].min;
                    clipPlaneZ.constant = (globalMaxMin[2].max - globalMaxMin[2].min) * guiparams.clippingz / 100.0 + globalMaxMin[2].min;
                }
                
                // ---- Camera & Navigation ----
                var camFolder = gui.addFolder( 'Camera' );
                const cameraTypes = { Perspective: 'Perspective', Orthographic: 'Orthographic' };
                camFolder.add( guiparams, 'cameraType', cameraTypes ).name('Wire Display').onChange( cameraChange );
                camFolder.add( guiparams, 'navright' ).name('View Right');
                camFolder.add( guiparams, 'navtop' ).name('View Top');
                camFolder.add( guiparams, 'navfront' ).name('View Front');
                function navChange( v ) {
                    var t = new THREE.Vector3();
                    new THREE.Box3().setFromObject(scene).getSize( t );
                    persControls.object.position.set( v[0]*t.x + camCenter.x, v[1]*t.y + camCenter.y, v[2]*t.z + camCenter.z);
                    persControls.target = camCenter;
                    persControls.update();
                    orthControls.object.position.set( v[0]*t.x + camCenter.x, v[1]*t.y + camCenter.y, v[2]*t.z + camCenter.z);
                    orthControls.target = camCenter;
                    orthControls.update();
                }
                function cameraChange( v ) {
                    cameraType = v;
                }
                
                var guiObjData = [];
                var guiObjects = gui.addFolder( 'Objects' );
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    guiObjData.push( {index: obj, color: data.objects[obj].color, opacity:data.objects[obj].opacity } );
                    var guiObject = guiObjects.addFolder( objects[obj].name );
                    guiObject.addColor( guiObjData[ guiObjData.length-1 ], 'color' ).name('Color').onChange( GUIObjectChange );
                    guiObject.add( guiObjData[ guiObjData.length-1 ], 'opacity' ).min(0.0).max(1.0).step(0.05).name('Opacity').onChange( GUIObjectChange );
                }
                function GUIObjectChange( v ) {
                    for ( var f=0; f<objects[this.object.index].faces.length; f++ ) {
                        var m = scene.getObjectByName( objects[this.object.index].faces[f] ).material;
                        if (this.property == 'color') { m.color.setStyle( v ); }
                        if (this.property == 'opacity') {
                            m.opacity = v;
                            if ( v == 1.0 ) { m.transparent = false; } else { m.transparent = true; }
                        }
                    }
                    if (this.property == 'opacity' && objects[ this.object.index ].wires.length > 0) {
                        var w = scene.getObjectByName( objects[ this.object.index ].wires[0] ).material; // all wires in obj share mat
                        w.opacity = v;
                        if ( v == 1.0 ) { w.transparent = false; } else { w.transparent = true; }
                    }
                }
                
                // Make simple orientation arrows and box - REF: http://jsfiddle.net/b97zd1a3/16/
                var arrowCanvasSize = { x: 150, y: 150 }; // in pixels on the lower left
                var arrowRenderer = new THREE.WebGLRenderer( { alpha: true } ); // clear
                arrowRenderer.setClearColor( 0x000000, 0 );
                arrowRenderer.setSize( arrowCanvasSize.x, arrowCanvasSize.y );
                
                var arrowCanvas = document.body.appendChild( arrowRenderer.domElement );
                arrowCanvas.setAttribute('id', 'arrowCanvas');
                arrowCanvas.style.width = arrowCanvasSize.x;
                arrowCanvas.style.height = arrowCanvasSize.y;
                      
                var arrowScene = new THREE.Scene();
                
                var arrowCamera = new THREE.PerspectiveCamera( 50, arrowCanvasSize.x / arrowCanvasSize.y, 1, 500 );
                arrowCamera.up = persCamera.up; // important!
                
                var arrowPos = new THREE.Vector3( 0,0,0 );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 1,0,0 ), arrowPos, 60, 0x7F2020, 20, 10 ) );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 0,1,0 ), arrowPos, 60, 0x207F20, 20, 10 ) );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 0,0,1 ), arrowPos, 60, 0x20207F, 20, 10 ) );
                arrowScene.add(new THREE.Mesh(
                    new THREE.BoxGeometry( 40, 40, 40 ),
                    new THREE.MeshLambertMaterial( { color: 0xaaaaaa, flatShading: false } )
                ));
                arrowScene.add(new THREE.HemisphereLight(0xC7E8FF, 0xFFE3B3, 1.2));
                
                // Controls
                var persControls = new OrbitControls( persCamera, renderer.domElement );
                persControls.target = camCenter; // rotate around center of parts
                persControls.update();
                var orthControls = new OrbitControls( orthCamera, renderer.domElement );
                orthControls.target = camCenter; // rotate around center of parts
                orthControls.update();
                
                window.addEventListener( 'resize', onWindowResize, false );
                onWindowResize();
                
                var stats = new Stats();
                document.body.appendChild( stats.dom );
                
                renderer.domElement.addEventListener( 'mousemove', onMouseMove );
                
                var animate = function () {
                    requestAnimationFrame( animate );
                    
                    persControls.update();
                    if (cameraType == 'Perspective') {
                        arrowCamera.position.copy( persCamera.position );
                        arrowCamera.position.sub( persControls.target );
                    }
                    orthControls.update();
                    if (cameraType == 'Orthographic') {
                        arrowCamera.position.copy( orthCamera.position );
                        arrowCamera.position.sub( orthControls.target );
                    }
                    arrowCamera.lookAt( arrowScene.position );
                    arrowCamera.position.setLength( 200 );
                    
                    stats.begin();
                    if (cameraType == 'Perspective') { renderer.render( scene, persCamera ); }
                    if (cameraType == 'Orthographic') { renderer.render( scene, orthCamera ); }
                    arrowRenderer.render( arrowScene, arrowCamera );
                    stats.end();
                };
                animate();
                
                function onWindowResize() {
                    for ( var obj=0; obj<objects.length; obj++ ) {
                        if (objects[obj].wires.length > 0) {
                            var w = scene.getObjectByName( objects[obj].wires[0] ).material.resolution.set( window.innerWidth, window.innerHeight ); // all wires in obj share mat
                        }
                    }
                    
                    // Ortho camera needs updating. REF: https://stackoverflow.com/questions/39373113/three-js-resize-window-not-scaling-properly
                    var aspect = window.innerWidth / window.innerHeight;
                    var change = originalAspect / aspect;
                    var newSize = viewSize * change;
                    orthCamera.left = -aspect * newSize / 2;
                    orthCamera.right = aspect * newSize  / 2;
                    orthCamera.top = newSize / 2;
                    orthCamera.bottom = -newSize / 2;
                    orthCamera.updateProjectionMatrix();
                    
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                
                function onMouseMove( e ) {
                    var c = false;
                    if (cameraType == 'Orthographic') { c = orthCamera;}
                    if (cameraType == 'Perspective') { c = persCamera;}
                    if (!c) { return; }
                    
                    var raycaster =  new THREE.Raycaster();                                        
                    raycaster.setFromCamera( new THREE.Vector2(
                        ( e.clientX / window.innerWidth ) * 2 - 1,
                        -( e.clientY / window.innerHeight ) * 2 + 1
                    ), c );
                    var intersects = raycaster.intersectObjects( raycasterObj );
                    
                    var chosen = '';
                    if ( intersects.length > 0 ) {
                        for ( var i=0; i<intersects.length; i++ ) {
                            var m = intersects[i].object.material;
                            if (m.opacity > 0) {
                                if (m.emissive.getHex() == 0x000000) {
                                    m.emissive.setHex( 0x777777 );
                                    m.needsUpdate = true;
                                }
                                chosen = intersects[i].object.name;
                                break;
                            }
                        }
                    }
                    for ( var r=0; r<raycasterObj.length; r++ ) {
                        if (raycasterObj[r].name == chosen) { continue; }
                        if (raycasterObj[r].material.emissive.getHex() != 0x000000) {
                            raycasterObj[r].material.emissive.setHex( 0x000000 );
                            raycasterObj[r].material.needsUpdate = true;
                        }
                    }
                }
                data = false; // free up some ram
            </script>
        </body>
    </html>
    
