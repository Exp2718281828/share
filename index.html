<!DOCTYPE html>
    <html lang="en">
        <head>
            <title>minecart2</title>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
            <meta name="generator" content="FreeCAD 0.19.24267 +148 (Git)" />
            <style>
                * { margin:0; padding:0; }
                body{
                    background: #ffffff; /* Old browsers */
                    background: -moz-linear-gradient(top, #e3e9fc 0%, #ffffff 70%, #e2dab3 100%); /* FF3.6-15 */
                    background: -webkit-linear-gradient(top, #e3e9fc 0%,#ffffff 70%,#e2dab3 100%); /* Chrome10-25, Safari5.1-6 */
                    background: linear-gradient(to bottom, #e3e9fc 0%,#ffffff 70%,#e2dab3 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
                }
                canvas { display: block; }
                #arrowCanvas  {
                  position: absolute;
                  left: 0px;
                  bottom: 0px;
                  z-index: 100;
                }
                select { width: 170px; }
            </style>
        </head>
        <body>
            <script type="module">
                
                // Direct from mrdoob - r122(10/28/20): https://www.jsdelivr.com/package/npm/three
                import * as THREE from            'https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.module.js';
                import { OrbitControls } from     'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/controls/OrbitControls.js';
                import Stats from                 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/libs/stats.module.js';
                import { GUI } from               'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/libs/dat.gui.module.js';
                import { Line2 } from             'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/Line2.js';
                import { LineMaterial } from      'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/LineMaterial.js';
                import { LineGeometry } from      'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/lines/LineGeometry.js';
                import { EdgeSplitModifier } from 'https://cdn.jsdelivr.net/npm/three@0.122.0/examples/jsm/modifiers/EdgeSplitModifier.js';
                
                var disableCompression = false;
                var base = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!#$%&()*+-:;/=>?@[]^_,.{|}~`';
                var baseFloat = ',.-0123456789';
                
                THREE.Object3D.DefaultUp = new THREE.Vector3(0,0,1); // Z is up for FreeCAD
                
                var raycasterObj = []; // list of obj that can mouseover highlight 
                
                var scene = new THREE.Scene();
                
                var renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } ); // Clear bg so we can set it with css
                renderer.setClearColor( 0x000000, 0 );
                var mainCanvas = document.body.appendChild( renderer.domElement );
                mainCanvas.setAttribute('id', 'mainCanvas');
                
                // HemisphereLight gives different colors of light from the top and bottom simulating reflected light from the 'ground' and 'sky'
                scene.add(new THREE.HemisphereLight(0xC7E8FF, 0xFFE3B3, 0.4));
                
                var dLight1 = new THREE.DirectionalLight( 0xffffff, 0.4 );
                dLight1.position.set( 5, -2, 3 );
                scene.add( dLight1 );
                var dLight2 = new THREE.DirectionalLight( 0xffffff, 0.4 );
                dLight2.position.set( -5, 2, 3 );
                scene.add( dLight2 );
                
                var data = {"camera":{"type":"Orthographic","focalDistance":1767.531494140625,"position_x":3814.91162109375,"position_y":2433.46728515625,"position_z":2781.01123046875},"file":{},"objects":[{"name":"Body","color":"#cccccc","opacity":1.0,"verts":"2 g b f c b b e d f a b b j b f k d f h b f i b f b c b b l b l l b l b b b m b o l b o b b n c d n l b n m b n b c o b s n q c p q r p d r j b r i b t j b t h m f i m f h b t g b r g b t u d r l b s b b c b q c u q r l b w l b v l l w b l v b l w b l s b e f b m f l o b b o b b a b c n b l n b a n b n a b o o b n o b o n b n l s n e f n m f n l w n l v o l w o b v o b w n d r n b f n q r n b b o b r n b x j l r o l r j n r j o r j n t j o f j m f j l f i n t i n f h n t h n f g o r g n r g n t g m f g o f g l r g l f l l r l b r b b f b d r b q r b b b b b x e b w k b w b e w b o w l o w b k w q b c q u r b u r b k f b p r b o s b o v l n v l n w l n s o n s k n f j n f e n f g n f o n v o o w o n w n o v n o w n o s n k f n u rxb u rxb b c n p r n e w n k wxb b r o n r n n r o o r n q x p q%b p b%b o l f p n r o o f o m f l n r u n r l o r l o f l m f l l f b n r q b r u b%b u q%b b q x l l%b o l%b b u%b q u%b q b x l o%b b p%b b n c q n c q p r b n x k n w e n w n n c nxb c pxb r bxb c uxb r n n xxb n cxb p r n p%b n u%b o o%bxb u%bxb b xxb n r nxb r n b%b n q%b o b%b bxb r q n r l b%b b b%b b q%b b l%b q b%b b o%b q p%b q n x b n f b n b u n%b p n%b uxb%b bxb x n n f n n b pxb%b nxb xxb n xxb p%b n l%b n o%bxb b%b o n%b l n%b b n%b q n%b bxb%b n n%b nxb%bxb n%b","facets":"2 a b c d e f d b a d a g d g h d h e i j k b k l b i k m i b d m b n d o p n q p d n r m d r d p s t u t d u f v d d v u f w v w e x f e w x y z e h x x h y A B g g B h C D E g a D g D C a c F a F D G H I b G I J c b J b I F c J K L M l k G k M G G M L M N O k j P M k N N k P Q m R i m Q P j i S T U V W S V U m V S U X m r X r Y X V m Z X Y 1 Z Y 2 X Z q 3 p r 4 5 r p 4 6 7 8 q n 3 n 8 3 3 8 7 8 9 0 n o t 8 n 9 9 n t G b l t o d ! # $ # % $ % u $ % s u w & v & $ v & ! $ 9 t ( ( t s $ u v ) w x w * & ) * w + - : ; / - - / : / z : ) z / ) x z / = ) h B y B > y B ? > > z y > : z A g C @ A C [ A @ A ? B [ ? A ] ^ _ , . ] , ] _ E , _ E { , D { E | , { E @ C _ @ E } F ~ F { D } { F `abbbcb `bb Icbbb Hcb Iab ~bb ~ Jbb ~ F Jdb H L H G L J Ibb Meb Kfb 8 0 M 8ebeb 8fbeb L K N Pdbdb P H O Ngb Ogb Mhbibjbib Mjbjb Mgb H Pkb P ikb Qlb i ilbkb Qmblb Rnbobmb Rob Q Rmbnb m Unb R mpb U Tqbibhb T Spb Sibqb Sqbpbrbsbib S Wtbib Stbibtbrb X 2ubvbwb Xwb ? Xxb Vybyb V [ [ V ? ? V X W VtbzbAbBb 2 Zub ZAbzb ZzbubCbDbAb Z 1EbAb ZEbAbEbCb 5Fb rFb Y r YEb 1Gb 4Hb 4 pHb 3Ib p pIbHb 3 sIb 5 4GbJb 5GbFb 5Jb 8Kb 6AbDbLb 8AbKbKbAbLb ( s 7 s 3 7 7 6Kb 0 9fb s %Ib #Mb % %MbIb # !Mb * ! & *Gb !NbObPbPbObJb *PbGbGbPbJb 9 (QbRbfb 9Rb 9QbSbfbRb )Tb * =Tb ) +Ub -UbPb -UbNbPbPb ; -Vb ;Pb /VbWb ;Vb / /Wb = =WbTb ? + > > + : ?wb + ^ [ @ ^ @ _yb [ ^XbYbZbYb ]ZbYb ^ ] .1bZb .Zb ]2b . ,1b .2b2b ,3b3b , |3b | {3b { }ab } ~abmb }ob4bZb4bXbZbZb }obob }mbab `5b `cb5bcbkb5bcb Hkbeb6b7b Leb7b8b L7bdb L8bSb6bebSbebfb9b0b 89b 8 M!bgb#bgb N#b N$b#b Ndb$b%b9b M%b Mibjbqbhbgb&bjb!b&bgbmbablblbab5b5bkblbpb(b)b Upb)b*bnb U*b U)bobnb*bpbqb+bpb+b(b-bBbAb:b-bAbib:bAbsb:bib(b+brbtb(brbrb:bsbub;b/b Xub/b=bvb X=b X/bUbvb=bwbvbUbwbUb +Ybyb ^xbybYb(btb>btb V>bxb?b V V?b>bxbYb?bubzb@bub@b;bzbBb-bEb;b@bEb@bCbLbDbCb;bEb[bEb Y[bFb]b Y Y]b[bFbJb]b !GbMbMbGbHbIbMbHb^b_bKb^bKbLb0b,bAb0bAb 8Kb_b.b 7Kb.b{b 7.b ( 7{bJbOb]b]bOb|bNbUb=b}bNb=bObNb}bWbVbPb *WbPbTbWb * (~b`b (`bQbacSbRb`bacRb~bac`bQb`bRbYbXb?bXbbc?bXb4bbc2b3b }Zb2b }1b2bZb4bob*b4b*bccdcecfc7bdcfc6bdc7becdb8bec8bfc8b7bfc6b9bdc0bSbac0b9b6b0b6bSbecgchcgc#bhcgc!b#bdbec$b$bechc$bhc#b,b%bAbAb%bib!bgc9b%bic&b9b%b&b9b&b!bjb&bjckcqbjbkcjbjc+bqbkclc4bccmclccc)bmccc(bmc)bcc*b)bnc-b:bncoc-bnc:bpcrbqc:b:bqcpcrb+bqcrcOb}bscrc}b/bsc}b;bsc/b}b=b/b4blcbclcmcbcmc>bbcmc(b>b?bbc>b-boctcuczb-buc-btc@bzbucCb@bvcLbCbvcwcLbvc^bLbwcObrc|brcsc|bsc[b|bsc;b[b[b]b|b_b0bxcyc,b^b,b0b_b,b_b^bxc~bzc.bxczc_bxc.b~b ({b~b{bzczc{b.b~b0bacxc0b~b9becdc9bgcecAcoc,bnc%bococ%b,bncBc%bBcCc%b%bCcicicCcDcjcicDc&bicjcCc+bkcCckcDckcjcDcCcBcEcBcpcEcBcncpc+bCcqcqcCcEcpcqcEcAcFcGctcAcGcocActcFc@bucFcucGcGcuctc@bFcHc@bHcvcyc^bwcHcycwcFcycHcHcwcvcFcAcycycAc,b","wires":["1abbcddebfgbfhbfibfjbfkdfadd","1abbcbblbbllbblbbcbbmbnmbncbnlbolbobbabb","1pqrpdrkdfaddobsnbcnqcpqr","1kbfjbfjbrpdrkdf","1ibtibfjbfjbrjbtibt","1hbfhmfimfibfhbf","1hbthbfgbfgbrgbthbt","1gbfedfubrgbrgbf","1uqrudredfcddlbsbbcbqcuqr","1lbvlbslbbllbllwlbwlbv","1llbblbblsblvblwllwllb","1bcbbmbbmfbefbcd","1bcdblsblbbcb","1nabnmbbmbbabbobloblnbcnbanbonboobnobnab","1nlsnlbncbnls","1ncbnefnmfnmbncb","1nlvnlsnlbolbolwnlwnlv","1olbobbobsobvobwolwolb","1lbblbscbblbb","1obsobbaddobs","1nqcnbcnbbnbfndrnqrnqc","1nqrnbrobrpdrpqrnqr","1obvnbxnbcobsobv","1pqrnqrnqcpqr","1pbrjbrjlrolrobrpbr","1jnrjorjofjmfjlfjlrjbrjbtjntjnr","1intinfimfibfibtint","1jbtibtintjntjbt","1hnthnfhmfhbfhbthnt","1imfhmfhnfinfimf","1gntgbtgbrglrglfgmfgofgorgnrgnt","1hbtgbtgnthnthbt","1ubrlbrlyrlzrlArlBrlCrlDrlErlFrlGrlHrlIrllrglrgbrubr","1bqcbbcbbbbbfbdrbqrbqc","1uqrubrlbrbdrbqruqr","1bbclbslbvbbxbbc","1bqruqrbqcbqr","1ebwlbwlywlzwlAwlBwlCwlDwlEwlFwlGwlHwlIwllwolwobwkbwebw","1lbwebwJbKLbMNbOPbQRbSTbUVbWXbYZb12b34b56b78b90b!#b$lbvlbw","1bdxblvbl%bl&bl(bl)bl*bl+bl-bl:bl;bl/bl=bl>bl?bl@bl[blsbbcbbx","1blwbewbJKbLMbNObPQbRSbTUbVWbXYbZ1b23b45b67b89b0!b#$blvblw","1llwblwbewbkwbowlowllw","1qurburbefbcdblsbbcqbcqur","2 b m f b k f b ] ^ b _ , b . { b | } b ~ ` babbb bcbdb bebfb bgbhb bibjb bkblb bmbnb b p r b u r b e f b m f","2 b k f b m f b mob b mpb b mqb b mrb b msb b mtb b mub b mvb b mwb b m b b a d b k f","1babbobbosbab","1bobloblowbowbovbosbob","1lnvlnslnbloblowlnwlnv","1onbonsanbonb","1knfjnfinfhnfgnfenfcnbandknf","1cndlnslnbcnb","1onbooboowonwonvonsonb","1novnosnobooboownownov","1nmbnmfnkfnabnmb","1nosnobnadnos","2xb b c n d c n l s n c b n e f n u rxb u rxb b c","2 n m f n e f nyb ^ nzb , nAb { nBb } nCb ` nDbbb nEbdb nFbfb nGbhb nHbjb nIblb nJbnb n u r n p r n k f n m f","1nlwolwoownownkwnewnlw","1ndxnlvnl%nl&nl(nl)nl*nl+nl-nl:nl;nl/nl=nl>nl?nl@nl[nlsnbcnbx","1nlwnewnJKnLMnNOnPQnRSnTUnVWnXYnZ1n23n45n67n89n0!n#$nlvnlw","2 o b w o b vKb bLbMb bNbOb bPbQb bRbSb bTbUb bVbWb bXbYb bZb1b b2b3b b4b5b b6b7b b8b9b b0b!b b#b$b b $ k b w o b w","2xb b r n b r n b f n b b n b cxb b cxb b r","1nbrobrolrooronrnnrnprnurnbr","2 p q%b p b%b k b w o b v n b x n q x p q%b","1jlrjlfolfolrjlr","1oorjorjnrpnronroor","1ooroofjofjoroor","1omfjmfjofoofomf","1jlfolfomfjmfjlf","1jntjnrjnfinfintjnt","1gntgnrgnfhnfhntgnt","1gorlorlnrunrgnrgor","1gorgofloflorgor","1gmflmflofgofgmf","1llflmfgmfglfllf","1llrllfglfglrllr","1lbrbbrburbprbnrlnrlorllrlbr","1qbcbbcbbbbbfbbrqbrqbc","2 b q x d b x l b v e b w u b%b u q%b b q x","2 k b w p b%b&b b%b(b b%b)b b%b*b b%b+b b%b-b b%b:b b%b;b b%b/b b%b=b b%b>b b%b?b b%b@b b%b[b b%b m b%b u b%b e b w k b w","2 o l%b o l w l l w l l%b o l%b","2 q b x b d x b l v b e w b u%b q u%b q b x","2 l l%b l l w l o w l o%b l l%b","2 b o w b k w b]b K b^b M b_b O b,b Q b.b S b{b U b|b W b}b Y b~b 1 b`b 3 bac 5 bbc 7 bcc 9 bdc ! b$b $ b o v b o w","2 b e w b u%b b p%b b k w b e w","1qbrbbrburqurqbr","1qbrqbcqurqbr","1qprbprbkfbadbosbncqncqpr","2 b o v b n x b nec b nfc b ngc b nhc b nic b njc b nkc b nlc b nmc b nnc b noc b npc b n [ b n c b o s b o v","1lnwenwknwonwoowlowlnw","1lnsbncdnxlnvlns","1enwlnwlnMlnOlnQlnSlnUlnWlnYln1ln3ln5ln7ln9ln!ln$lnvenw","2 pxb r p n r k n f a n d o n s n n c nxb c pxb r","1jnfknfpnrjnrjnf","1enfgnfgnrunrenf","2 uxb r u n r e n f c n d l n s b n c bxb c uxb r","2 o n v n n x n nec n nfc n ngc n nhc n nic n njc n nkc n nlc n nmc n nnc n noc n npc n n [ n n c o n s o n v","2 o n w k n w]b n K^b n M_b n O,b n Q.b n S{b n U|b n W}b n Y~b n 1`b n 3ac n 5bc n 7cc n 9dc n !$b n $ o n v o n w","1nosnncnnxnovnos","2 n o w n o v nKbLb nMbNb nObPb nQbRb nSbTb nUbVb nWbXb nYbZb n1b2b n3b4b n5b6b n7b8b n9b0b n!b#b n$b $ n k w n o w","2xb p r n p r n k f n a d n o s n n cxb n cxb p r","2xb u r n u r n b rxb b rxb u r","2xb b rxb u rxb b cxb b r","2 n k w n p%b n&b%b n(b%b n)b%b n*b%b n+b%b n-b%b n:b%b n;b%b n/b%b n=b%b n>b%b n?b%b n@b%b n[b%b n m%b n u%b n e w n k w","2 o o%b o o w o l w o l%b o o%b","2xb b x n d x n l v n e w n u%bxb u%bxb b x","2xb n r n n r n p rxb p rxb n r","2 nxb r n n r o n r p n r pxb r nxb r","1omfoofoorolrolfomf","2 n q x n b x n b%b n q%b n q x","2 n q%b n b%b o b%b p b%b p q%b n q%b","2 n q%b p q%b n q x n q%b","2 bxb r b n r l n r u n r uxb r bxb r","1lmfllfllrlorloflmf","1qnrbnrbprqprqnr","2 u q%b u b%b l b%b b b%b b q%b u q%b","2 b q%b b b%b b b x b q x b q%b","2 b q%b d q x u q%b b q%b","2 l b%b u b%b p b%b o b%b o l%b l l%b l b%b","2 q u%b b u%b b l%b b b%b q b%b q u%b","2 q b%b b b%b b b x q b x q b%b","2 q b x q b%b q u%b q b x","2 o o w o o%b l o%b l o w o o w","2 b u%b b p%b b o%b l o%b l l%b b l%b b u%b","2 q n x b n x b o v b k w b p%b q p%b q n x","1qncbncbnbbnfbnrqnrqnc","1qncqnrqprqnc","2 k n w p n%b u n%b e n w k n w","2 bxb x d n x l n v e n w u n%b uxb%b bxb x","2 nxb c n n c n n b n n f n n r nxb r nxb c","2 nxb r pxb r nxb c nxb r","2 bxb c b n c b n b b n f b n r bxb r bxb c","2 bxb r bxb c uxb r bxb r","2 nxb x n n x o n v k n w p n%b pxb%b nxb x","2xb p%b n p%b n k w n o v n n xxb n xxb p%b","2xb n c n n c n n b n n f n n rxb n rxb n c","2xb p rxb n rxb n cxb p r","2 o o%b n o%b n p%b n u%b n l%b o l%b o o%b","2xb u%b n u%b n l%b n b%bxb b%bxb u%b","2xb b%b n b%b n b xxb b xxb b%b","2xb b%bxb d xxb u%bxb b%b","2 o b%b n b%b n l%b o l%b o b%b","2 b b%b l b%b l l%b b l%b b b%b","2 u n%b l n%b lqc%b lrc%b lsc%b ltc%b luc%b lvc%b lwc%b lxc%b lyc%b lzc%b lAc%b l o%b o o%b o n%b p n%b u n%b","2 l n%b b n%b b o%b l o%b l n%b","2 q p%b b p%b b o%b b n%b q n%b q p%b","2 q n%b b n%b b n x q n x q n%b","2 q n%b q n x q p%b q n%b","2 uxb%b u n%b l n%b b n%b bxb%b uxb%b","2 bxb%b b n%b b n x bxb x bxb%b","2 bxb x bxb%b uxb%b bxb x","2 pxb%b p n%b o n%b n n%b nxb%b pxb%b","2 nxb%b n n%b n n x nxb x nxb%b","2 nxb%b nxb x pxb%b nxb%b","2xb n x n n x n n%bxb n%bxb n x","2xb n%b n n%b n o%b n p%bxb p%bxb n%b","2xb n%bxb p%bxb n xxb n%b","2 n n%b o n%b o o%b n o%b n n%b"],"faceColors":[],"facesToFacets":["1abcdef","1ghijklmnop","1qrstu","1vw","1xyz","1AB","1CDE","1FG","1HIJKL","1MNOP","1QRST","1UV","1W","1XYZ1234567","18","190","1!#$%","1&()*","1+","1-","1:;/=","1>?@","1[]","1^","1_,.","2 { | } ~ `abbb","2cbdbeb","2fbgb","2hbibjb","2kblb","2mbnbobpbqbrbsb","2tbub","2vbwbxb","2ybzbAbBb","2CbDbEb","2FbGb","2Hb","2IbJbKbLb","2Mb","2NbOb","2Pb","2QbRbSbTb","2UbVbWbXbYb","2Zb1b2b","23b4b","25b","26b7b8b9b","20b!b#b$b","2%b","2&b(b)b*b+b-b","2:b","2;b/b=b>b","2?b@b[b]b","2^b_b","2,b","2.b{b|b}b~b","2`bacbc","2ccdcecfc","2gchc","2ic","2jc","2kclcmcnc","2ocpcqcrcsctc","2ucvcwcxc","2yczc","2AcBcCc","2DcEc","2FcGc","2HcIc","2JcKcLc","2McNcOc","2PcQcRc","2ScTc","2UcVc","2WcXc","2YcZc","21c2c3c4c5c6c","27c8c9c0c","2!c#c$c%c","2&c(c","2)c*c","2+c-c:c;c","2/c=c","2>c","2?c@c","2[c]c","2^c","2_c,c.c{c|c","2}c~c","2`cadbdcd","2dded","2fd","2gdhdidjdkd","2ldmd","2ndod","2pdqdrdsdtd","2udvd","2wd","2xdyd","2zd","2AdBdCdDdEd","2FdGd","2Hd","2IdJd","2KdLd","2MdNdOdPd","2QdRd","2SdTdUd","2VdWdXd","2YdZd","21d2d3d","24d","25d6d7d","28d9d0d","2!d#d","2$d%d&d","2(d)d","2*d","2+d-d:d;d","2/d=d>d","2?d@d","2[d","2]d^d","2_d,d.d{d","2|d}d~d`d","2aebecede","2ee","2fege","2heiejeke","2lemeneoe","2pe","2qeresete","2ue","2vewexeye","2zeAeBeCe","2DeEeFeGe","2He","2IeJeKeLe","2MeNeOe","2PeQe","2Re","2SeTe","2UeVe","2WeXeYeZe","21e2e","23e4e5e","26e7e","28e","29e0e!e","2#e$e","2%e","2&e(e)e","2*e+e","2-e","2:e;e","2/e=e>e","2?e","2@e[e"],"floats":"S{wE_?TvI5UvRaTuT2mbrtLv`9Uv_shD+Cuu#5UvpuQ;IXuc}4UvpN0Il-dud0UvpuQ;!azgx^TvRaTuO#Pc~4Uvu{+(X0|te?Tv~@yi:,TS=~Jve0Uv:mX3`QCu}4UvF%3EjNBu+4Uv0qGw_HLiq`UuvA1bnAQU~`N@TimT/Ew@([mTeIdmj)z]YaUcetLvOxU{diMJKyj8u*{.[hMJ3~2FBb/,YhMJgk/Rd/N^[gMJ4p%%>Jz=mfMJT5FTk){!6bMJ@JD-i9qM4.LJJve5@YT5QQIJrvQyzgKzB>EJf+eD]Z,E:#jJ=qsL@5~P@1@I>3U3|JP!hw)G3eLv/9BL,DTF7{Kvgr53UFrD0!Kvb0UvDc>wqGMv-kJ{U/{VR@d9zV$WuO=uD)[f];+0Lv{kl%U>=nPY2,SDd@@S3n.AQM,Esxv9!N*fDcBLsl[i@#_)`%Lvgr53g6yWZ>))|k[v.5yWH8MY!qGw85yWl5{@npDxk5yWN[;-Cvwz53yWfKY6eCTEe1yWBNdDkV3NOUyW{>qL9CF8$gvWEHT3UDTG-TrWM?Jv$[mT}HkW$?Jv[qL+!#yU@@Jvgr53pA:T(]Jv`9Uvs}2CcF08D$r5K*QBS^qbA>AL2CMl#7Np>>Jver53Ili]Z(HbpXKv~@yi%61WN%%M%qGwZzhDQR*AA]~*W2-HUG&d%z5%Z*qlhs5WW%U3([mTiZmF>/nuL5Uv!^kB90Pc.5+@ZslB90PcewS-PTlB90PcfN-57jmB90Pc2.>z$HnB80Pc[n>F}7qB60Pc=y$R^txB20PcVdd&`KKB(8PcKU~TiY_Hq1PcQ%~-oc%OYUPc91*6>+X9CJPc^=FDlAaIXbPc=5BL5rlVeLOcjn53MGm(MBMcm6UvewqV:~Ic}4Uvv8g5l7duf0&.%:+SS?_>1=0mq9,Dp8S5xlB]KsBc7$vwjBw%kOzHmiwW`iUSz|T32CMlPN/DV]Tv5N.HlDxc|4Uv2v,Vl-duGnhwV|BWWr^=KQOirgsE7=!DO}V;MhDcZi[#lBWz(jJ&.=hZm+TWbJO@z8Um:@vEYKK+`RxBbGEcfm53z/|vDLBuq5.3)ZiI>r&fVQQQX5Fl_OY/:d~@T8vX/Z6{N/b9UtixQv8u>JUf^bBL2CMlxY.(hXKv0`pnlvzG2nqN-UO]nRRc)uF41~8Gt#AHmiwW%ZB=kfU32CMlPmyGw^Tvs6!u5dRcE4Uv"}]};
                
                function baseDecode( input ) {
                    var baseCt = base.length;
                    var output = [];
                    var len = parseInt( input[0] ); // num chars of each element
                    for ( var i=1; i<input.length; i+=len ) {
                        var str = input.substring(i, i+len).trim();
                        var val = 0;
                        for ( var s=0; s<str.length; s++ ) {
                            var ind = base.indexOf(str[s]);
                            val += ind * Math.pow(baseCt, s);
                        }
                        output.push(val);
                    }
                    return output;
                }
                function floatDecode( input ) {
                    var baseCt = base.length;
                    var baseFloatCt = baseFloat.length;
                    var numString = '';
                    for ( var i=0; i<input.length; i+=4 ) {
                        var b90chunk = input.substring(i, i+4).trim();
                        var quotient = 0;
                        for ( var s=0; s<b90chunk.length; s++ ) {
                            var ind = base.indexOf(b90chunk[s]);
                            quotient += ind * Math.pow(baseCt, s);
                        }
                        var buffer = '';
                        for ( var s=0; s<7; s++ ) {
                            buffer = baseFloat[ quotient % baseFloatCt ] + buffer;
                            quotient = parseInt(quotient / baseFloatCt);
                        }
                        numString += buffer;
                    }
                    var trailingCommas = 0;
                    for ( var s=1; s<7; s++ ) {
                        if( numString[ numString.length-s ] == baseFloat[0] ) { trailingCommas++; }
                    }
                    numString = numString.substring(0, numString.length - trailingCommas);
                    return numString;
                }
                // Decode from base90 and distribute the floats
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    if (!disableCompression) {
                        data.objects[obj].floats = JSON.parse('[' + floatDecode( data.objects[obj].floats ) + ']');
                        data.objects[obj].verts = baseDecode( data.objects[obj].verts );
                        for ( var v=0; v<data.objects[obj].verts.length; v++ ) {
                            data.objects[obj].verts[v] = data.objects[obj].floats[ data.objects[obj].verts[v] ];
                        }
                        data.objects[obj].facets = baseDecode( data.objects[obj].facets );
                        for ( var w=0; w<data.objects[obj].wires.length; w++ ) {
                            data.objects[obj].wires[w] = baseDecode( data.objects[obj].wires[w] );
                            for ( var wv=0; wv<data.objects[obj].wires[w].length; wv++ ) {
                                data.objects[obj].wires[w][wv] = data.objects[obj].floats[ data.objects[obj].wires[w][wv] ];
                            }
                        }
                        for ( var f=0; f<data.objects[obj].facesToFacets.length; f++ ) {
                            data.objects[obj].facesToFacets[f] = baseDecode( data.objects[obj].facesToFacets[f] );
                        }
                    }
                    data.objects[obj].floats = false;
                }
                
                // Get bounds for global clipping
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    if (obj == 0) {
                        var globalMaxMin = [{min:data.objects[obj].verts[0],max:data.objects[obj].verts[0]},
                                            {min:data.objects[obj].verts[1],max:data.objects[obj].verts[1]},
                                            {min:data.objects[obj].verts[2],max:data.objects[obj].verts[2]}]
                    }
                    for ( var v=0; v<data.objects[obj].verts.length; v++ ) {
                        if ( data.objects[obj].verts[v] < globalMaxMin[v % 3].min ) { globalMaxMin[v % 3].min = data.objects[obj].verts[v]; }
                        if ( data.objects[obj].verts[v] > globalMaxMin[v % 3].max ) { globalMaxMin[v % 3].max = data.objects[obj].verts[v]; }
                    }
                }
                var bigrange = 0;
                for ( var i=0; i<globalMaxMin.length; i++ ) { // add a little extra
                    var range = globalMaxMin[i].max - globalMaxMin[i].min;
                    if ( range > bigrange ) { bigrange = range; }
                    globalMaxMin[i].min -= range * 0.01;
                    globalMaxMin[i].max += range * 0.01;
                }
                
                var camCenter = new THREE.Vector3(
                    0.5 * (globalMaxMin[0].max - globalMaxMin[0].min) + globalMaxMin[0].min,
                    0.5 * (globalMaxMin[1].max - globalMaxMin[1].min) + globalMaxMin[1].min,
                    0.5 * (globalMaxMin[2].max - globalMaxMin[2].min) + globalMaxMin[2].min );
                var viewSize = 1.5 * bigrange; // make the view area a little bigger than the object
                var aspectRatio = window.innerWidth / window.innerHeight;
                var originalAspect = aspectRatio 
                function initCam(camera) {
                    camera.position.set(
                        data.camera.position_x,
                        data.camera.position_y,
                        data.camera.position_z);
                    camera.lookAt( camCenter );
                    camera.updateMatrixWorld();
                }
                var cameraType = data.camera.type;
                var persCamera = new THREE.PerspectiveCamera( data.camera.focalDistance, window.innerWidth / window.innerHeight, 1, 10000 );
                initCam(persCamera);
                var orthCamera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, -10000, 10000);
                initCam(orthCamera);
                
                function assignMesh( positions, color, opacity ) {
                    
                    var geometry = new THREE.BufferGeometry();
                    geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                    
                    // EdgeSplitModifier is used to combine verts so that smoothing normals can be generated WITHOUT removing the hard edges of the design
                    // REF: https://threejs.org/examples/?q=edge#webgl_modifier_edgesplit - https://github.com/mrdoob/three.js/pull/20535
                    var edgeSplit = new EdgeSplitModifier();
                    var cutOffAngle = 20;
                    geometry = edgeSplit.modify( geometry, cutOffAngle * Math.PI / 180 );
                    geometry.computeVertexNormals();
                    geometry.computeBoundingSphere();
                    
                    var transparent = false;
                    if (opacity != 1.0) { transparent = true; }
                    var material = new THREE.MeshLambertMaterial({
                        color: color,
                        side: THREE.DoubleSide,
                        vertexColors: false,
                        flatShading: false,
                        opacity: opacity,
                        transparent: transparent,
                        fog: false
                    });
                    
                    var meshobj = new THREE.Mesh( geometry, material );
                    meshobj.name = meshobj.uuid;
                    faces.push( meshobj.uuid );
                    scene.add( meshobj );
                    raycasterObj.push(meshobj);
                }
                
                var objects = [];
                var positions;
                for ( var obj=0; obj<data.objects.length; obj++ ) { // Loop Objects
                    
                    var faces = []; // Each face gets its own material because they each can have different colors
                    if (data.objects[obj].facesToFacets.length > 0) {
                        for ( var f=0; f<data.objects[obj].facesToFacets.length; f++ ) {
                            var facecolor = data.objects[obj].color;
                            if (data.objects[obj].faceColors.length > 0) {
                                facecolor = data.objects[obj].faceColors[f];
                            }
                            positions = new Float32Array( data.objects[obj].facesToFacets[f].length * 9 );
                            for ( var a=0; a<data.objects[obj].facesToFacets[f].length; a++ ) {
                                for ( var b=0; b<3; b++ ) {
                                    for ( var c=0; c<3; c++ ) {
                                        positions[ 9*a + 3*b + c ] = data.objects[obj].verts[ 3*data.objects[obj].facets[ 3*data.objects[obj].facesToFacets[f][a] + b ] + c ];
                                    }
                                }
                            }
                            assignMesh( positions, facecolor, data.objects[obj].opacity );
                        }
                    } else { // No facesToFacets means that there was a tessellate() mismatch inside FreeCAD. Use all facets in object create this mesh
                        positions = new Float32Array( data.objects[obj].facets.length * 3 );
                        for ( var a=0; a<data.objects[obj].facets.length; a++ ) {
                            for ( var b=0; b<3; b++ ) {
                                positions[ 3*a + b ] = data.objects[obj].verts[ 3*data.objects[obj].facets[a] + b ];
                            }
                        }
                        assignMesh( positions, data.objects[obj].color, data.objects[obj].opacity );
                    }
                    
                    // Wires
                    // cannot have lines in WebGL that are wider than 1px due to browser limitations so Line2 workaround lib is used
                    // REF: https://threejs.org/examples/?q=fat#webgl_lines_fat - https://jsfiddle.net/brLk6aud/1/
                    var wirematerial = new LineMaterial( {
                        color: new THREE.Color('rgb(0,0,0)'),
                        linewidth: 2, // in pixels
                        dashed: false, dashSize: 1, gapSize: 1, dashScale: 3
                    } );
                    wirematerial.resolution.set( window.innerWidth, window.innerHeight );
                    
                    var wires = [];
                    for ( var w=0; w<data.objects[obj].wires.length; w++ ) {
                        var wiregeometry = new LineGeometry();
                        wiregeometry.setPositions( data.objects[obj].wires[w] );
                        var wire = new Line2( wiregeometry, wirematerial );
                        wire.computeLineDistances();
                        wire.scale.set( 1, 1, 1 );
                        wire.name = wire.uuid;
                        scene.add( wire );
                        wires.push( wire.name );
                    }
                    objects.push( { name: data.objects[obj].name, faces: faces, wires: wires } );
                }
                
                // ---- GUI Init ----
                const gui = new GUI( { width: 300 } );
                var guiparams = {
                    wiretype: 'Normal',
                    wirewidth: wirematerial.linewidth,
                    wirecolor: '#'+wirematerial.color.getHexString(),
                    clippingx: 100,
                    clippingy: 100,
                    clippingz: 100,
                    cameraType: cameraType,
                    navright: function() { navChange( [1,0,0] ); },
                    navtop:   function() { navChange( [0,1,0] ); },
                    navfront: function() { navChange( [0,0,1] ); }
                };
                
                // ---- Wires ----
                if (!wirematerial.visible) { guiparams.wiretype = 'None'; }
                if (wirematerial.dashed) { guiparams.wiretype = 'Dashed'; }
                const wiretypes = { Normal: 'Normal', Dashed: 'Dashed', None: 'None' };
                
                var wireFolder = gui.addFolder( 'Wire' );
                wireFolder.add( guiparams, 'wiretype', wiretypes ).name('Wire Display').onChange( wireChange );
                wireFolder.add( guiparams, 'wirewidth').min(1).max(5).step(1).name('Wire Width').onChange( wireChange );
                wireFolder.addColor( guiparams, 'wirecolor' ).name('Wire Color').onChange( wireChange );
                wireFolder.close();
                
                function wireChange() {
                    for ( var obj=0; obj<objects.length; obj++ ) {
                        if ( objects[obj].wires.length == 0 ) { continue; }
                        var m = scene.getObjectByName( objects[obj].wires[0] ).material; // all wires in obj share mat
                        if (m.dashed) {
                            if (guiparams.wiretype != 'Dashed') {
                                m.dashed = false;
                                delete m.defines.USE_DASH;
                            }
                        } else {
                            if (guiparams.wiretype == 'Dashed') {
                                m.dashed = true;
                                // Dashed lines require this as of r122. delete if not dashed
                                m.defines.USE_DASH = ""; // https://discourse.threejs.org/t/dashed-line2-material/10825
                            }
                        }
                        if (guiparams.wiretype == 'None') {
                            m.visible = false;
                        } else {
                            m.visible = true;
                        }
                        m.linewidth = guiparams.wirewidth;
                        m.color = new THREE.Color(guiparams.wirecolor);
                        m.needsUpdate = true;
                    }
                }
                wireChange();
                
                // ---- Clipping ----
                var clippingFolder = gui.addFolder( 'Clipping' );
                clippingFolder.add( guiparams, 'clippingx').min(0).max(100).step(1).name('X-Axis Clipping').onChange( clippingChange );
                clippingFolder.add( guiparams, 'clippingy').min(0).max(100).step(1).name('Y-Axis Clipping').onChange( clippingChange );
                clippingFolder.add( guiparams, 'clippingz').min(0).max(100).step(1).name('Z-Axis Clipping').onChange( clippingChange );
                clippingFolder.close();
                
                var clipPlaneX = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), 0 );
                var clipPlaneY = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), 0 );
                var clipPlaneZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), 0 );
                function clippingChange() {
                    if( guiparams.clippingx < 100 || guiparams.clippingy < 100 || guiparams.clippingz < 100 ) {
                        if (renderer.clippingPlanes.length == 0) {
                            renderer.clippingPlanes.push( clipPlaneX, clipPlaneY, clipPlaneZ );
                        }
                    }
                    clipPlaneX.constant = (globalMaxMin[0].max - globalMaxMin[0].min) * guiparams.clippingx / 100.0 + globalMaxMin[0].min;
                    clipPlaneY.constant = (globalMaxMin[1].max - globalMaxMin[1].min) * guiparams.clippingy / 100.0 + globalMaxMin[1].min;
                    clipPlaneZ.constant = (globalMaxMin[2].max - globalMaxMin[2].min) * guiparams.clippingz / 100.0 + globalMaxMin[2].min;
                }
                
                // ---- Camera & Navigation ----
                var camFolder = gui.addFolder( 'Camera' );
                const cameraTypes = { Perspective: 'Perspective', Orthographic: 'Orthographic' };
                camFolder.add( guiparams, 'cameraType', cameraTypes ).name('Wire Display').onChange( cameraChange );
                camFolder.add( guiparams, 'navright' ).name('View Right');
                camFolder.add( guiparams, 'navtop' ).name('View Top');
                camFolder.add( guiparams, 'navfront' ).name('View Front');
                function navChange( v ) {
                    var t = new THREE.Vector3();
                    new THREE.Box3().setFromObject(scene).getSize( t );
                    persControls.object.position.set( v[0]*t.x + camCenter.x, v[1]*t.y + camCenter.y, v[2]*t.z + camCenter.z);
                    persControls.target = camCenter;
                    persControls.update();
                    orthControls.object.position.set( v[0]*t.x + camCenter.x, v[1]*t.y + camCenter.y, v[2]*t.z + camCenter.z);
                    orthControls.target = camCenter;
                    orthControls.update();
                }
                function cameraChange( v ) {
                    cameraType = v;
                }
                
                var guiObjData = [];
                var guiObjects = gui.addFolder( 'Objects' );
                for ( var obj=0; obj<data.objects.length; obj++ ) {
                    guiObjData.push( {index: obj, color: data.objects[obj].color, opacity:data.objects[obj].opacity } );
                    var guiObject = guiObjects.addFolder( objects[obj].name );
                    guiObject.addColor( guiObjData[ guiObjData.length-1 ], 'color' ).name('Color').onChange( GUIObjectChange );
                    guiObject.add( guiObjData[ guiObjData.length-1 ], 'opacity' ).min(0.0).max(1.0).step(0.05).name('Opacity').onChange( GUIObjectChange );
                }
                function GUIObjectChange( v ) {
                    for ( var f=0; f<objects[this.object.index].faces.length; f++ ) {
                        var m = scene.getObjectByName( objects[this.object.index].faces[f] ).material;
                        if (this.property == 'color') { m.color.setStyle( v ); }
                        if (this.property == 'opacity') {
                            m.opacity = v;
                            if ( v == 1.0 ) { m.transparent = false; } else { m.transparent = true; }
                        }
                    }
                    if (this.property == 'opacity' && objects[ this.object.index ].wires.length > 0) {
                        var w = scene.getObjectByName( objects[ this.object.index ].wires[0] ).material; // all wires in obj share mat
                        w.opacity = v;
                        if ( v == 1.0 ) { w.transparent = false; } else { w.transparent = true; }
                    }
                }
                
                // Make simple orientation arrows and box - REF: http://jsfiddle.net/b97zd1a3/16/
                var arrowCanvasSize = { x: 150, y: 150 }; // in pixels on the lower left
                var arrowRenderer = new THREE.WebGLRenderer( { alpha: true } ); // clear
                arrowRenderer.setClearColor( 0x000000, 0 );
                arrowRenderer.setSize( arrowCanvasSize.x, arrowCanvasSize.y );
                
                var arrowCanvas = document.body.appendChild( arrowRenderer.domElement );
                arrowCanvas.setAttribute('id', 'arrowCanvas');
                arrowCanvas.style.width = arrowCanvasSize.x;
                arrowCanvas.style.height = arrowCanvasSize.y;
                      
                var arrowScene = new THREE.Scene();
                
                var arrowCamera = new THREE.PerspectiveCamera( 50, arrowCanvasSize.x / arrowCanvasSize.y, 1, 500 );
                arrowCamera.up = persCamera.up; // important!
                
                var arrowPos = new THREE.Vector3( 0,0,0 );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 1,0,0 ), arrowPos, 60, 0x7F2020, 20, 10 ) );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 0,1,0 ), arrowPos, 60, 0x207F20, 20, 10 ) );
                arrowScene.add( new THREE.ArrowHelper( new THREE.Vector3( 0,0,1 ), arrowPos, 60, 0x20207F, 20, 10 ) );
                arrowScene.add(new THREE.Mesh(
                    new THREE.BoxGeometry( 40, 40, 40 ),
                    new THREE.MeshLambertMaterial( { color: 0xaaaaaa, flatShading: false } )
                ));
                arrowScene.add(new THREE.HemisphereLight(0xC7E8FF, 0xFFE3B3, 1.2));
                
                // Controls
                var persControls = new OrbitControls( persCamera, renderer.domElement );
                persControls.target = camCenter; // rotate around center of parts
                persControls.update();
                var orthControls = new OrbitControls( orthCamera, renderer.domElement );
                orthControls.target = camCenter; // rotate around center of parts
                orthControls.update();
                
                window.addEventListener( 'resize', onWindowResize, false );
                onWindowResize();
                
                var stats = new Stats();
                document.body.appendChild( stats.dom );
                
                renderer.domElement.addEventListener( 'mousemove', onMouseMove );
                
                var animate = function () {
                    requestAnimationFrame( animate );
                    
                    persControls.update();
                    if (cameraType == 'Perspective') {
                        arrowCamera.position.copy( persCamera.position );
                        arrowCamera.position.sub( persControls.target );
                    }
                    orthControls.update();
                    if (cameraType == 'Orthographic') {
                        arrowCamera.position.copy( orthCamera.position );
                        arrowCamera.position.sub( orthControls.target );
                    }
                    arrowCamera.lookAt( arrowScene.position );
                    arrowCamera.position.setLength( 200 );
                    
                    stats.begin();
                    if (cameraType == 'Perspective') { renderer.render( scene, persCamera ); }
                    if (cameraType == 'Orthographic') { renderer.render( scene, orthCamera ); }
                    arrowRenderer.render( arrowScene, arrowCamera );
                    stats.end();
                };
                animate();
                
                function onWindowResize() {
                    for ( var obj=0; obj<objects.length; obj++ ) {
                        if (objects[obj].wires.length > 0) {
                            var w = scene.getObjectByName( objects[obj].wires[0] ).material.resolution.set( window.innerWidth, window.innerHeight ); // all wires in obj share mat
                        }
                    }
                    
                    // Ortho camera needs updating. REF: https://stackoverflow.com/questions/39373113/three-js-resize-window-not-scaling-properly
                    var aspect = window.innerWidth / window.innerHeight;
                    var change = originalAspect / aspect;
                    var newSize = viewSize * change;
                    orthCamera.left = -aspect * newSize / 2;
                    orthCamera.right = aspect * newSize  / 2;
                    orthCamera.top = newSize / 2;
                    orthCamera.bottom = -newSize / 2;
                    orthCamera.updateProjectionMatrix();
                    
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                
                function onMouseMove( e ) {
                    var c = false;
                    if (cameraType == 'Orthographic') { c = orthCamera;}
                    if (cameraType == 'Perspective') { c = persCamera;}
                    if (!c) { return; }
                    
                    var raycaster =  new THREE.Raycaster();                                        
                    raycaster.setFromCamera( new THREE.Vector2(
                        ( e.clientX / window.innerWidth ) * 2 - 1,
                        -( e.clientY / window.innerHeight ) * 2 + 1
                    ), c );
                    var intersects = raycaster.intersectObjects( raycasterObj );
                    
                    var chosen = '';
                    if ( intersects.length > 0 ) {
                        for ( var i=0; i<intersects.length; i++ ) {
                            var m = intersects[i].object.material;
                            if (m.opacity > 0) {
                                if (m.emissive.getHex() == 0x000000) {
                                    m.emissive.setHex( 0x777777 );
                                    m.needsUpdate = true;
                                }
                                chosen = intersects[i].object.name;
                                break;
                            }
                        }
                    }
                    for ( var r=0; r<raycasterObj.length; r++ ) {
                        if (raycasterObj[r].name == chosen) { continue; }
                        if (raycasterObj[r].material.emissive.getHex() != 0x000000) {
                            raycasterObj[r].material.emissive.setHex( 0x000000 );
                            raycasterObj[r].material.needsUpdate = true;
                        }
                    }
                }
                data = false; // free up some ram
            </script>
        </body>
    </html>
    
